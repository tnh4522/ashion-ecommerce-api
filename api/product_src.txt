api/product/product_views.py
# product_views.py
from django_filters.rest_framework import DjangoFilterBackend, FilterSet, NumberFilter, CharFilter
from rest_framework import filters as drf_filters, status, permissions
from rest_framework.response import Response
from rest_framework import generics
from api.models import Product, OrderItem
from api.product.product_serializers import ProductSerializer
from api.views import StandardResultsSetPagination
from .recommendation_serializer import ProductRecommendationSerializer
from django.db.models import Q
from django.utils import timezone

class ProductRecommendationView(generics.ListAPIView):
    serializer_class = ProductRecommendationSerializer
    permission_classes = [permissions.AllowAny]

    def get_queryset(self):
        one_week_ago = timezone.now() - timezone.timedelta(days=1)

        queryset = Product.objects.filter(Q(sale_price__isnull=True))

        queryset = queryset.exclude(
            id__in=OrderItem.objects.filter(
                order__created_at__gte=one_week_ago
            ).values_list('product_id', flat=True)
        )

        # queryset = queryset.filter(
        #     Q(created_at__lte=one_week_ago) &
        #     Q(updated_at__lte=one_week_ago)
        # )

        return queryset

class ProductFilter(FilterSet):
    price__gte = NumberFilter(field_name="price", lookup_expr='gte')
    price__lte = NumberFilter(field_name="price", lookup_expr='lte')
    category__name = CharFilter(field_name='category__name', lookup_expr='icontains')
    status = CharFilter(field_name='status', lookup_expr='exact')
    name = CharFilter(field_name='name', lookup_expr='icontains')
    name_exact = CharFilter(field_name='name', lookup_expr='iexact')

    class Meta:
        model = Product
        fields = ['category__name', 'price', 'status', 'name', 'name_exact']

class ProductCreateView(generics.CreateAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    permission_classes = [permissions.AllowAny]

    def perform_create(self, serializer):
        serializer.save()

class ProductListView(generics.ListAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    permission_classes = [permissions.AllowAny]
    filter_backends = [DjangoFilterBackend, drf_filters.SearchFilter, drf_filters.OrderingFilter]
    filterset_class = ProductFilter
    search_fields = ['name']
    ordering_fields = ['price', 'name', 'stock', 'status', 'category__name']
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        queryset = super().get_queryset()
        request = self.request
        category_names = request.query_params.getlist('category__name', [])
        name_exact = request.query_params.get('name_exact', None)
        search = request.query_params.get('search', None)

        if category_names:
            queryset = queryset.filter(category__name__in=category_names).distinct()

        if name_exact:
            queryset = queryset.filter(name__iexact=name_exact)
        elif search:
            queryset = queryset.filter(name__icontains=search)

        return queryset

class ProductDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    permission_classes = [permissions.AllowAny]

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        instance.status = 'INACTIVE'
        instance.save()
        return Response(status=status.HTTP_204_NO_CONTENT)


_________________
api/product/product_serializers.py

from rest_framework import serializers
from ..models import Category, Product, Tag, ProductImage, StockVariant, Stock
from .variant_serializers import StockVariantSerializer
from django.db import transaction
from django.db.models import Sum
import logging

logger = logging.getLogger(__name__)

class ProductImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProductImage
        fields = ['id', 'image', 'is_main', 'caption', 'alt_text', 'order']

class ProductSerializer(serializers.ModelSerializer):
    user = serializers.StringRelatedField(read_only=True)
    category = serializers.PrimaryKeyRelatedField(queryset=Category.objects.all(), required=False, allow_null=True)
    images = ProductImageSerializer(source='product_images', many=True, read_only=True)
    stock_variants = StockVariantSerializer(many=True, read_only=True)
    tags = serializers.PrimaryKeyRelatedField(queryset=Tag.objects.all(), many=True, required=False)

    class Meta:
        model = Product
        fields = [
            'id', 'user', 'name', 'slug', 'sku', 'barcode', 'brand', 'description',
            'material', 'care_instructions', 'category', 'price',
            'sale_price', 'start_sale_date', 'end_sale_date', 'stock', 'weight',
            'dimensions', 'sizes', 'colors', 'status', 'is_featured',
            'is_new_arrival', 'is_on_sale', 'main_image', 'video_url',
            'meta_title', 'meta_description', 'slug', 'images', 'stock_variants', 'tags'
        ]
        read_only_fields = ('user', 'slug', 'stock_variants')
        ref_name = 'ProductStockSerializer'

    def create(self, validated_data):
        user = self.context['request'].user
        tags = validated_data.pop('tags', [])
        images = self.context['request'].FILES.getlist('images')
        product = Product.objects.create(user=user, **validated_data)
        product.tags.set(tags)

        for index, image in enumerate(images):
            ProductImage.objects.create(
                product=product,
                image=image,
                order=index
            )

        self.sync_stock_variants(product)

        return product

    def get_main_image(self, obj):
        if obj.images.exists():
            request = self.context.get('request')
            image_url = obj.images.first().image.url
            return request.build_absolute_uri(image_url)
        return None

    def update(self, instance, validated_data):
        tags = validated_data.pop('tags', None)
        replaced_image_ids = self.context['request'].data.getlist('replaced_image_id')
        new_images = self.context['request'].FILES.getlist('images')

        original_sizes = set([size.strip().upper() for size in instance.sizes.split(',') if size.strip()])
        original_colors = set([color.strip().upper() for color in instance.colors.split(',') if color.strip()])

        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()

        if tags is not None:
            instance.tags.set(tags)

        for replaced_id, new_image in zip(replaced_image_ids, new_images):
            try:
                product_image = ProductImage.objects.get(id=replaced_id, product=instance)
                product_image.image = new_image
                product_image.save()
            except ProductImage.DoesNotExist:
                continue

        remaining_images = new_images[len(replaced_image_ids):]
        for new_image in remaining_images:
            ProductImage.objects.create(
                product=instance,
                image=new_image,
                is_main=False,
                order=instance.product_images.count()
            )

        new_sizes = set([size.strip().upper() for size in validated_data.get('sizes', '').split(',') if size.strip()])
        new_colors = set([color.strip().upper() for color in validated_data.get('colors', '').split(',') if color.strip()])

        sizes_changed = original_sizes != new_sizes
        colors_changed = original_colors != new_colors

        if sizes_changed or colors_changed:
            self.sync_stock_variants(instance, new_sizes, new_colors)

            self.update_product_stock(instance)

        return instance

    def sync_stock_variants(self, product, new_sizes=None, new_colors=None):

        if new_sizes is None:
            sizes = set([size.strip().upper() for size in product.sizes.split(',') if size.strip()])
        else:
            sizes = new_sizes

        if new_colors is None:
            colors = set([color.strip().upper() for color in product.colors.split(',') if color.strip()])
        else:
            colors = new_colors

        valid_variant_names = set(f"{size} - {color}" for size in sizes for color in colors)
        active_stocks = Stock.objects.filter(is_active=True)

        with transaction.atomic():
            for stock in active_stocks:
                for variant_name in valid_variant_names:
                    variant, created = StockVariant.objects.get_or_create(
                        product=product,
                        stock=stock,
                        variant_name=variant_name,
                        defaults={'quantity': 0}
                    )
                    if created:
                        logger.info(f"Created StockVariant: {variant_name} for Product: {product.name} at Stock: {stock.name}")

            existing_variants = StockVariant.objects.filter(product=product)
            invalid_variants = existing_variants.exclude(variant_name__in=valid_variant_names)
            count_deleted = invalid_variants.count()
            if count_deleted > 0:
                invalid_variants.delete()
                logger.info(f"Deleted {count_deleted} invalid StockVariants from Product: {product.name}")
            else:
                logger.info(f"No invalid StockVariants found for Product: {product.name}")

    def update_product_stock(self, product):
        total_quantity = StockVariant.objects.filter(product=product).aggregate(total=Sum('quantity'))['total'] or 0
        product.stock = total_quantity
        product.save(update_fields=['stock'])
        logger.info(f"Updated Product Stock: {product.name} - Total Quantity: {total_quantity}")

    def validate(self, attrs):
        sizes = set([size.strip().upper() for size in attrs.get('sizes', '').split(',') if size.strip()])
        colors = set([color.strip().upper() for color in attrs.get('colors', '').split(',') if color.strip()])

        variant_names = [f"{size} - {color}" for size in sizes for color in colors]
        if len(variant_names) != len(set(variant_names)):
            raise serializers.ValidationError("There are duplicate variant names.")

        return attrs

_________________
api/product/product_filters.py
# products/filters.py

import django_filters
from .models import Product

class ProductFilter(django_filters.FilterSet):
    name_exact = django_filters.CharFilter(field_name='name', lookup_expr='exact')
    search = django_filters.CharFilter(field_name='name', lookup_expr='icontains')

    class Meta:
        model = Product
        fields = {
            'name_exact': ['exact'],
            'search': ['icontains'],
            'categories__name': ['in'],
            'status': ['exact'],
            'price__gte': ['exact', 'gte'],
            'price__lte': ['exact', 'lte'],
        }

_________________
api/product/stock_serializers.py
from rest_framework import serializers
from ..models import Stock

class StockSerializer(serializers.ModelSerializer):
    class Meta:
        model = Stock
        fields = ['id', 'name', 'description', 'is_active', 'location', 'created_at', 'updated_at']


_________________
api/product/product_urls.py
# product_urls.py
from django.urls import path
from .product_views import *
from .variant_views import *

urlpatterns = [
    path('list/', ProductListView.as_view(), name='product-manager'),
    path('create/', ProductCreateView.as_view(), name='product-create'),
    path('detail/<int:pk>/', ProductDetailView.as_view(), name='product-detail'),
    path('stock-variants/<int:pk>/', StockVariantUpdateView.as_view(), name='stock-variant-update'),
    path('stock-variants/<int:pk>/delete/', StockVariantDestroyView.as_view(), name='stock-variant-delete'),
    path('update_stock_variants/', UpdateStockVariantsAPIView.as_view(), name='update_stock_variants'),
    path('recommendations/', ProductRecommendationView.as_view(), name='product-recommendation'),
]

_________________
api/product/variant_views.py
from rest_framework import generics, permissions
from ..models import StockVariant
from .variant_serializers import StockVariantSerializer
from rest_framework.permissions import IsAuthenticated, IsAdminUser
from rest_framework.views import APIView
from rest_framework import status, permissions
from rest_framework.response import Response
from .variant_serializers import StockVariantUpdateSerializer
from django.db import transaction

class StockVariantUpdateView(generics.UpdateAPIView):
    queryset = StockVariant.objects.all()
    serializer_class = StockVariantSerializer
    permission_classes = [IsAuthenticated, IsAdminUser] 

    def update(self, request, *args, **kwargs):
        kwargs['partial'] = True
        response = super().update(request, *args, **kwargs)
        return response
    def put(self, request, *args, **kwargs):
        return super().put(request, *args, **kwargs)

class StockVariantDestroyView(generics.DestroyAPIView):
    queryset = StockVariant.objects.all()
    serializer_class = StockVariantSerializer
    permission_classes = [IsAuthenticated, IsAdminUser]

class UpdateStockVariantsAPIView(APIView):
    permission_classes = [permissions.IsAdminUser]
    def put(self, request, format=None):

        data = request.data
        if not isinstance(data, list):
            return Response({"detail": "Invalid data format. Expected a list of objects."},
                            status=status.HTTP_400_BAD_REQUEST)

        serializer = StockVariantUpdateSerializer(data=data, many=True)
        if serializer.is_valid():
            try:
                with transaction.atomic():
                    for item in serializer.validated_data:
                        variant = StockVariant.objects.get(id=item['id'])
                        variant.quantity = item['quantity']
                        variant.save()
                return Response({"detail": "StockVariants updated successfully."}, status=status.HTTP_200_OK)
            except Exception as e:
                return Response({"detail": str(e)}, status=status.HTTP_400_BAD_REQUEST)
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

_________________
api/product/recommendation_serializer.py
from rest_framework import serializers
from api.models import Product

class ProductRecommendationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'name', 'price', 'sale_price', 'created_at', 'updated_at']

_________________
api/product/variant_serializers.py
from rest_framework import serializers
from ..models import StockVariant, Stock
from .stock_serializers import StockSerializer


class StockVariantSerializer(serializers.ModelSerializer):
    stock = StockSerializer(read_only=True)
    stock_id = serializers.PrimaryKeyRelatedField(
        queryset=Stock.objects.all(), source='stock', write_only=True
    )
    quantity = serializers.IntegerField()

    class Meta:
        model = StockVariant
        fields = ['id', 'product', 'stock', 'variant_name', 'quantity', 'created_at', 'updated_at', 'stock_id', 'image']
        read_only_fields = ['id', 'product', 'variant_name', 'created_at', 'updated_at']

    def update(self, instance, validated_data):
        instance.quantity = validated_data.get('quantity', instance.quantity)
        if 'stock' in validated_data:
            instance.stock = validated_data['stock']
        if 'image' in validated_data:
            instance.image = validated_data['image']
        instance.save()
        return instance

class StockVariantUpdateSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    quantity = serializers.IntegerField(min_value=0)

    def validate_id(self, value):
        if not StockVariant.objects.filter(id=value).exists():
            raise serializers.ValidationError("StockVariant with this ID does not exist.")
        return value

    def update(self, instance, validated_data):
        instance.quantity = validated_data.get('quantity', instance.quantity)
        instance.save()
        return instance

_________________